This file is the doc for p3.

1. Understanding Kaleidoscope's parser and AST
	1) virtual的作用：
		在ExprAST中有三个虚函数，其中一个是析构函数，另外两个是纯虚函数，分别是代码生成和处理dot图的函数，留给其子类来实现，其作为基类，提供了一个接口，其他各种的表达式所代表的子类均继承自其，在代码中可以以基类类型作为形参和返回值，因为可以将基类和派生类进行转换。
		对于派生类的继承的虚函数，不同类有不同的实现，在调用时可以进行动态绑定到自身的成员函数，其在运行时确定而不是像非虚成员函数在编译时确定。
		对于vtable，其派生类必须要实现纯虚函数，因此在其类的vtable中包含的是被复写后的函数指针，在调用虚函数时，因为一般在编译时无法确定调用其的对象类型，因此留到运行时进行处理，在运行时因为已经知道调用对象的类型了，可以选择相应的函数
		这样的设计也符合工厂模式，使整体的代码具有更好的维护性，例如我扩展while语句时只要添加一个对应的类以及其相关的函数即可，无需改动之前的代码。
	2) HandleDefinition和HandleToplevelExpression函数的解释以及其对应的AST：
		在调用HandleDefinition时，说明其遇到了"def"关键词，故其将剩下的按照函数的定义来处理，即调用ParseDefinition函数
		在调用HandleTopLevelExpression时，其也当做函数处理，只是没有函数声明。在调用ParseTopLevelExpression函数时，其创建了一个空的函数声明，并将剩下的作为表达式利用ParseExpression函数处理，最后将两者合起来创建一个FunctionAST对象返回
	3) Lexer和Parser之间传递信息的形式：
		在Lexer中，主要是一个gettok函数，其返回token的类型(其定义为一组枚举类型的变量)，若是数字或者标识符则将其值分别保存到全局变量IdentifierStr和NumVal，在Parser中可以随时使用
		在Parser中，也有对应的getNextToken函数调用Lexer中的getTok函数并返回token类型，同时将token的类型保存到CurTok全局变量中
	4) 算符优先级的处理：
		其在main函数的一开始就用map保存了各个运算符的优先级，并用一个GetTokPrecedence函数返回运算符的优先级，若不是运算符则返回-1
		在ParseBinOpRHS函数中，其是一个递归的函数，先判断当前的运算符优先级是否小于函数调用时传入的表达式优先级也即原传入的LHS中运算符的优先级，若小于则直接返回传入的LHS,不进行任何操作，否则将binop保存至BinOp中，吃掉该运算符并将剩下的交给ParseUnary函数处理，将结果返回到RHS中
		若RHS后的运算符优先级大于之前的运算符，则将RHS作为LHS递归调用自己，否则将LHS与RHS合并保存到LHS中，并读取下一个运算符的优先级，如此不断循环，直至读到的运算符优先级小于表达式运算符或者RHS出错
		下面通过a*b*c, a*b+c, a+b*c这三个例子进行说明：
			a*b*c：
				这个是一般的表达式，只包含乘号，parser在处理这个表达式时，其先调用ParseUnary函数处理'a'，然后进行调用ParseBinOpRHS函数，其吃掉乘号并保存后，其进行处理乘号的右操作数,其返回的是'b'，然后进行合并，进行下一轮循环，依旧是类似的操作，然后进行第三轮循环，则发现读取的运算符优先级小于表达式优先级，因此返回LHS，工作到此结束
			a*b+c:
				基本同上，在此略去不表。只是在第二次循环中，处理的符号不同罢了
			a+b*c:
				在读到'*'之前基本相同，但在第二次循环中，发现NextPrec比当前运算符的优先级要大，因此利用RHS递归调用，在被递归调用的函数中，其进行了与之前类似的操作(都是处理一个双目运算符)，然后此时的RHS便成为了"b*c"，然后返回主调函数与LHS合并进入第三次循环中返回。
		总之，遇到后面的运算符优先级高于当前运算符的情况时，其优先处理后面的运算符，具体方法是对右操作数进行递归调用，待返回后再与LHS合并，最后返回。(注意到每次递归调用时传入的优先级都加了一，这在运算符优先级种类数不多的情况下适用，但种类多起来的话可能会出问题，这可以通过增加优先级数值之间的间隔解决)
	5) 各种出错处理函数的作用：
		这里总共有三个出错函数，其实归根结底还是Error函数，其将出错信息打到标准错误流中。这些函数的主要作用是将提供一个统一的报错机制，提高代码的可读性与可维护性，同时给用户以各类出错信息，使得用户可以更好的对自己的程序查错，否则到处都是fprintf不仅不美观还影响阅读。
		例如在函数声明时缺少左括号可以直接调用Error("expected '(' in prototype")
		在处理if表达式缺少then时调用Error("expected then")
	6) Kaleidoscope不支持声明变量，给变量赋值，那么变量的作用是什么？
		经过加入变量声明后已经解决这个问题，若在之前其可以作为for语句中的循环变量，或作为标识符便于程序员辨认
	7) 为什么不需要{...}或begin...end？
		Kaleidoscope并不支持多个语句组成的代码块，其只支持各种语句之间的嵌套，不存在多个语句并列成为一个完整代码段的情况，因此不需要这样的机制
	8) 如何避免if语句的二义性？
		在这个语言的定义中，其if语句必须包含then和else部分，不存在书本上有无else语句的情况，而且在处理if语句时，其将其每个部分都当做表达式进行处理，若遇到嵌套的if语句，其在返回外部的if语句之前已经处理完毕了，不存在二义性问题
		主要在于条件语句cond如何判定的问题，
	9) if的分支条件如何实现？
		即对cond部分的处理，在codegen部分中，对于if语句的代码生成，其对cond语句单独调用了其自身的代码生成函数，并将返回值与0作对比(调用llvm提供的createFCmpONE函数)，若为0则执行else语句部分，否则执行then部分。
		若cond语句中含'<'，则调用CreateFCmpULT函数进行处理，最后将返回的布尔值利用CreateUIToFP函数转化为1.0或0.0
		
2. While语句的实现
	要求中提供的while语句的文法规则非常简单，就是一个"while"后跟着2个表达式，因此可以仿照if语句的实现，在头文件中加上对应的类，其中有2个ExprAST*类型的成员变量Cond与Body,分别代表条件语句和循环体，另外还有构造函数，代码生成函数和画图的函数，其中代码生成函数只实现了一个空函数
	构造函数与其他类的定义基本类似，就是复用成员变量的拷贝构造函数，dumpdot函数也非常简单，基本与if语句的类似，在此略去不表
	在toy.cpp中，对相关部分也进行了修改，大概如下：
		在词法分析部分，我在枚举变量中增加了一个tok_while,并在gettok函数中增加了相应的返回语句。
		在语法分析部分，我增加了一个函数叫做ParseWhileExpr，实现也非常简单，一开始吃掉"while"，然后分别对后面的输入调用ParseExpression，将返回值分别赋给两个成员变量，同时也在判断返回值是否为0，若是则直接返回0，若都不是则返回利用Cond和Body构造出的WhileExprAST对象的指针。还有就是增加了ParsePrimary处理while语句的入口
		
	
	
