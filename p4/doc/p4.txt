一、
.y文件的格式如下：
%{
  Prologue
%}

Bison declarations

%%
Grammar rules
%%

Epilogue

Prologue 是一些头文件的包含和宏定义等
Bison declarations 是一些bison内置的选项，可以选择是否开启，还有就是一些定义之类的
Grammar rules 是作者提供的文法产生式以及其对应的操作
Epilogue 是一些C代码，最后会直接拷贝到bison生成的文件之中

bison与flex的协作
在.lex文件中可以包含bison生成的头文件，其会自动生成在.y中需要的token的定义，在yyparse函数中，其会调用yylex来读取下一个token
还有例如记录token的位置，可以在.y文件中加上%location选项，就可以使用一个YYLTYPE类型的结构体来记录每个token的位置，并在.lex文件中增加相应的YY_USER_ACTION即可
最终编译生成的语法分析器需要使用两者的生成文件，因此可以在.y文件中通过extern来引用flex的一些对象，例如修改yyin使其指向打开的文件等

生成的parser的接口形式以及特征
在生成的parser中，其主要提供了一个yyparse或者是yypush_parse与yypull_parse函数（取决于你的设置），你可以调用这个函数来完成语法分析，同时这个函数也会在分析之中调用yylex来读取下一个token
其有一个选项可以为yyparse函数提供形参，可以在产生式的语义动作中使用
还有就是yystate_new和yystate_delete函数，用来创建和删除一个新的parser
最后就是yyerror函数,其是自带的报错函数


文法对分析器和分析表的状态空间的影响
不同的文法产生的分析器显然是不一样的
分析表的构造是通过文法和书上给定的算法来执行产生的，文法的不同会影响分析表的大小，而其又是由非终结符个数和终结符的数量决定的
对于不同的文法，其也会产生不同数量的状态，因此在yyparse的yyreduce中的状态数也会不同

二、
1.expr的编译命令：
    bison -d -y -b expr -o src/expr.tab.c config/expr.y
    flex -i -I -o src/expr.lex.c config/expr.lex
    gcc -g -Iinclude -o bin/expr src/expr.tab.c src/expr.lex.c -ll -lm
    显然第一个是利用bison生成parser的源文件，第二个是利用flex生成词法分析器的源文件，第三个是用gcc编译形成可以用的词法分析器
    下面解释选项的含义：
    bison：
        -d 其会在生成.c文件的同时生成头文件，其包含了在.y文件中定义的token和一些其他的声明
        -y 其使用传统的Yacc语法来生成文件
        -b 指定输出文件的前缀
        -o 指定输出文件名
    flex: 
        -i 使其输出的为大小写敏感的词法分析器
        -I 生成的是交互式的词法分析器
        -o 指定输出文件名
    gcc:
        -g 产生调试信息
        -Iinclude 指定头文件的位置
        -o 指定输出文件名
        -ll 链接上Solaris's libl lex library
        -lm 链接上math的library
2.
    Yacc文件格式已在之前叙述过了，在此不再累述
    其完成表达式求值的方式：
        其在每个产生式之后增加对应的语义动作，例如expr PLUS expr后其将两个expr的值相加
        
3. 两个文件基本上相同，只有在部分地方有微小的差别，其中因为文件名不同的差别略去不表。因为两者的文法不相同，故产生的parser也不同，例如状态数，非终结符的个数，产生式的个数都不一样
还有就是状态转移和动作表也不同，以及yyparse函数中因为产生式和文法的不同有些许的差别。 总结一下就是两个主要的不同，基本都是因为文法的不同导致，一其自动创建的一些const数组中的元素不同，例如状态转移表等，二是规约的时候。
两个文法表达的是同一个语言，只是第二个通过添加更多的产生式来消除二义性，然而更加复杂的文法也会在其生成的文件中体现出来，主要就是更加复杂的状态转移表和规约状态以及对应的操作
4.
    .tab.c文件
    一开始都是一大堆宏定义，其中一些是作为后面需要的工具，例如栈的分配，头文件包含与那些原本写在.y最前面%{%}之间的那些东西
    接着是一些const的数组，就是bison利用算法产生的表，其用数字来指代各个状态和规约动作，
    接着是错误恢复的一些宏定义
    接着就是一些各种各样的辅助函数，例如各种打印函数，报错函数等
    接着是这个文件的核心部分，yyparse函数
    最后是.y文件最后的%%之后的内容
    .lex.c文件
    一开始与.tab.c文件类似，也是一大堆宏定义什么的，不过其定义了一个yy_buffer_state结构体，用来描述DFA中的状态
    然后是一大堆辅助函数的声明和算法产生的一大堆表格
    接着是这个文件的核心部分，yylex函数
    后面是之前声明的辅助函数的实现
    最后就是.lex文件最后的%%之后的内容
    
    
    
三、4.2的说明
    我没有用助教给的asign2ast模板，而是用的bison-example中的一些代码，并对一些地方进行了修改
    对于移进规约冲突，我通过定义优先级的方式已经全部解决，例如if else语句，我将有else的优先级定的高于没有else的
    在最后的程序中还是有几十个规约规约冲突，这是因为'+'和'-'解释的二义性，还有就是加上了缺括号的产生式
    bison默认采用第一个产生式进行规约，所以我把正确的写在前面，从而解决了这个问题，显然你不想在有两种规约方式的时候选择会产生错误的那个
    对于'+'和'-'的解释，我也是把加号的那个产生式写在正号的前面，优先按照加号进行规约，因为如果按照正号规约了就会产生缺少运算符的错误
    对错误的处理，我是在遇到错误产生式的时候产生一个错误，其在common.h中有定义，我在其中加了一个文件名，用于在最后指出出错的位置
    本来是想只保存一行的，就是在词法分析时保存每个token，最后在换行的时候删除，但发现其无法处理多行的错误，而且在发现错误时词法分析已经读到下一行了，于是保存的不是出错的那行
    后来也尝试过保存多行，但是无法把握将缓冲区清空的时机，而且那样会造成代码的混乱，最终还是决定将文件名作为形参传入yyparse函数中，然后保存到错误中，在分析完毕或者出错停止分析后
    将所有的错误和警告报出来。但是这样也牺牲了在stdin输入的可能性，因为你始终要建立一个缓冲区保存用户的输入，但你无法预见用户输入的大小
    在报错时，通过其给出的行号列号打出那一行并且用'^'来指示出错的位置，这只是通过扫描那一行，遇到tab键就输出其，其余输出空格即可
    为了防止移进规约冲突，我对可能的产生式设置了对应的优先级，从而解决了这个问题
    但是助教要求的三个错误也可以组合出向后只看一个token无法恢复的错误，即"if (a > b  c d = 1;"，这个表达式按照要求是可以恢复的，就按照bc间少运算符来处理，但是分析器只能向后看一个字符
    对c与d的处理应该是一样的，因为其优先级一样，如果都是一直移进，则会产生两个少符号错误，而在等号左边就没有左值了，若规约的话也不对
    我实现的分析器也支持多个文件的分析，也会区分错误所在的文件，但是不知道为什么在出未定义的错误后后面的若干个文件就无法分析
    
    在lex文件中加入了对单行注释的支持，以测试p1写的几个程序
    